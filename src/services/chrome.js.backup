class ChromeService {
  // Storage operations
  async setStorage(key, value) {
    return new Promise((resolve) => {
      chrome.storage.local.set({ [key]: value }, resolve);
    });
  }

  async getStorage(key) {
    return new Promise((resolve) => {
      chrome.storage.local.get([key], (result) => {
        resolve(result[key]);
      });
    });
  }

  async removeStorage(key) {
    return new Promise((resolve) => {
      chrome.storage.local.remove([key], resolve);
    });
  }

  async clearStorage() {
    return new Promise((resolve) => {
      chrome.storage.local.clear(resolve);
    });
  }

  // Notification operations
  showNotification(title, message, type = 'basic') {
    const notificationId = `xertiq-${Date.now()}`;
    
    chrome.notifications.create(notificationId, {
      type: type,
      iconUrl: '../icons/icon48.png',
      title: title,
      message: message
    });

    // Auto-clear notification after 5 seconds
    setTimeout(() => {
      chrome.notifications.clear(notificationId);
    }, 5000);
  }

  // Tab operations
  async openTab(url) {
    return new Promise((resolve) => {
      chrome.tabs.create({ url }, resolve);
    });
  }

  async getCurrentTab() {
    return new Promise((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        resolve(tabs[0]);
      });
    });
  }

  // Message passing
  sendMessage(message, responseCallback) {
    chrome.runtime.sendMessage(message, responseCallback);
  }

  onMessage(callback) {
    chrome.runtime.onMessage.addListener(callback);
  }

  // Background script communication
  async sendToBackground(action, data = {}) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage(
        { action, data },
        (response) => resolve(response)
      );
    });
  }

  // Network status checking
  async checkNetworkStatus() {
    try {
      const response = await fetch('http://localhost:3001/api/health', {
        method: 'GET',
        timeout: 5000
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // Extension lifecycle
  async getExtensionInfo() {
    return chrome.runtime.getManifest();
  }

  // Clipboard operations
  async copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      this.showNotification('Copied!', 'Text copied to clipboard');
      return true;
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      return false;
    }
  }

  // Download operations
  downloadFile(url, filename) {
    chrome.downloads.download({
      url: url,
      filename: filename,
      saveAs: true
    });
  }

  // Badge operations
  setBadgeText(text) {
    chrome.action.setBadgeText({ text: text });
  }

  setBadgeColor(color) {
    chrome.action.setBadgeBackgroundColor({ color: color });
  }

  // Context menu operations
  createContextMenu(id, title, contexts = ['page']) {
    chrome.contextMenus.create({
      id: id,
      title: title,
      contexts: contexts
    });
  }

  // Window operations
  async getPopupWindow() {
    return new Promise((resolve) => {
      chrome.windows.getCurrent(resolve);
    });
  }

  closePopup() {
    window.close();
  }

  // Permission checking
  async hasPermission(permission) {
    return new Promise((resolve) => {
      chrome.permissions.contains({ permissions: [permission] }, resolve);
    });
  }

  async requestPermission(permission) {
    return new Promise((resolve) => {
      chrome.permissions.request({ permissions: [permission] }, resolve);
    });
  }
}

export default new ChromeService();
